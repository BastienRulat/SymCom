/**
 * Formation => Symfony 5 : Le guide complet par Lior Chamla
 * Section   => La s√©curit√© : authentification
 * Chapter   => Les √©checs possibles pendant l'authentification
 *
 * MySubject => Les test de conformit√© sur la route et sur la m√©thode http ne suffisent pas.
 */
 
// PREMIERE EBAUCHE
// ON S'ASSURE QUE LES PARAMETRES EXISTENT BIEN
// ON FILTRE DIRECTEMENT DANS SUPPORTS
// ON EVITE AINSI DES ERREURS SERVEURS 500
// QUI NE SONT PAS CAPTURES PAR LA METHODE ONAUTHENTICATIONFAILURE

public function supports(Request $request) {

    // Test de conformit√© sur la route et sur la m√©thode http
    if ($request->attributes->get('_route') !== 'security_login' && !$request->isMethod('POST')) return false;
    
    // Test de conformit√© du form login
    $param = $request->request->getIterator('parameters')->key();
    if (is_null($param) || $param !== "login") return false;
    $login = $request->request->getIterator('parameters')->current();
    
    // Test d'existence des credentials
    // Ect-ce un cas mal g√©r√© par d√©faut dans notre LoginFormAuthenticator am√©liorable par Symfony ?
    if (!isset(
        $login['email'],
        $login['password'],
        $login['_token']
    )) return false;

    return true;
}

// DEUXIEME EBAUCHE
// ON DECOUVRE ALL
// BYE ITERATOR = CODE PLUS PROPRE

public function supports(Request $request) {

    // Test de conformit√© sur la route et sur la m√©thode http
    if ($request->attributes->get('_route') !== 'security_login' && !$request->isMethod('POST')) return false;

    // Test de conformit√© du form login
    $login = $request->request->all('login');
    if (empty($login)) return false;

    // Test d'existence des credentials
    if (!isset(
        $login['email'],
        $login['password'],
        $login['_token']
    )) return false;

    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////


// TROISIEME EBAUCHE
// ON FILTRE AU NIVEAU OU L'ERREUR APPARAIT UNE PREMIERE FOIS
// ON LEVE LES EXCEPTIONS POUR RECUPERE NOS MESSAGES DANS NOTRE FORMULAIRE

// Petit appart√© -> PB : Un user connect√© peut encore revenir sur le login.
// Qu'est-ce qui fait la dif sous le capot avec l'exemple d'apr√®s ? A suivre.

// Par contre vu que supprimer le token du form ne genere jamais d'erreur,
// avec cette approche on dit rien si on nous envoit un form foireux : pas tip top...
// Mais au mois zero erreur serveur 500 deja


public function supports(Request $request) {
    
    // Test de conformit√© de la route et de la m√©thode http
    return $request->attributes->get('_route') === 'security_login' && $request->isMethod('POST');
}

public function getCredentials(Request $request) {

    // Contrairement √† get qui renvoit null,
    // all renvoit [] si login n'xiste pas
    // Du coup pas la peine de tester l'ErrorException
    // N.B. Cet usage de get est d√©pr√©ci√©.

    return $request->request->all('login');
}

public function getUser($credentials, UserProviderInterface $userProvider) {

    // Esquive d'une ErrorException 1 premiere fois
    try {
        if (!isset($credentials['email'])) throw new ErrorException();
        return $userProvider->loadUserByUsername($credentials['email']);
    } catch (ErrorException $e) {
        throw new AuthenticationException ("Mail manqaant");
    } catch (UsernameNotFoundException $e) {
        throw new AuthenticationException ("Mail erron√©");
    }
}

public function checkCredentials($credentials, UserInterface $user) {

    // Esquive d'une ErrorException 1 deuxieme fois
    try {
        if (!isset($credentials['password'])) throw new ErrorException();
    } catch (ErrorException $e) {
        throw new AuthenticationException("Mdp manquant");
    }    
    
    $isValid = $this->encoder->isPasswordValid($user, $credentials['password']);
    if (!$isValid) {
        throw new AuthenticationException ("Mdp erronn√©");
    }
    
    return true;
}

public function onAuthenticationFailure(Request $request, AuthenticationException $exception) {

    $request->attributes->set(Security::AUTHENTICATION_ERROR, $exception);
    $request->attributes->set(Security::LAST_USERNAME, $request->request->get('login')['email'] ?? '');
}



public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $providerKey) {

    return new RedirectResponse("/");
}

public function start(Request $request, AuthenticationException $authException = null)
{
    // todo
    dump ("start");
}

public function supportsRememberMe()
{
    dump('supportRemember');
    // todo
}


////////////////////////////////////////////////////////////////////////////////////////////////////////


// QUATRIEME EBAUCHE
// ON PREND UN EAPPROCHE PLUS PREVENANTE ET AU LIEU D'ATTENDRE LES ERREURS,
// ON ANTICIPE
// INJECTONS 2 DANS 3 POUR TESTER L ANON EXISTENCE DES DONNEES DE NOTRE FORMULAIRE

On remplace donc juste supports.
La seule diff√©rence que l'on note :
- on test login
- on test token
==> On accepte plus silencieusement un formulaire corrompu
==> En retournant des false, un user connect√© peut toujours revenir sur login, ce qui n'a aucun sens.


////////////////////////////////////////////////////////////////////////////////////////////////////////

// CINQUIEME EBAUCHE
// DANS SUPPORTS, ON REMPLACE NOS DEUX DERNIERS RETURN FALSES (LE PREMIER EST CENSE) PAR DES LEVEES D'EXCEPTIONS.
// EN THEORIE, ON PEUT ALLEGER DU COUP NOS TRY CATCH PLUS BAS DESSOUS DU COUP MAIS LAISSONS POUR L'INSTANT CELA DE COTE.
// AJOUTER LES EXCEPTIONS IMPLIQUE QUE L'USER CONNECTE NE PEUT PLUS SE LOGGER
// ET START ET APPELLE; J'ENQUETE !

ON obtient quand on essait de revenir sur le formulaire de log :
The "App\Security\LoginFormAuthenticator::start()" method must return a Response object ("null" returned).
Avec ce code dans supports :

public function supports(Request $request) {

    // Test de conformit√© sur la route et sur la m√©thode http
    if ($request->attributes->get('_route') !== 'security_login' && !$request->isMethod('POST')) return false;
    
    // Test de conformit√© du form login
    $login = $request->request->all('login');
    if (empty($login)) throw new AuthenticationException("le formulaire est corrompu");
    
    // Test d'existence des credentials, un cas mal g√©r√© par d√©faut dans notre LoginFormAuthenticator
    if (!isset(
        $login['email'],
        $login['password'],
        $login['_token']
    )) throw new AuthenticationException("le formulaire est corrompu");
    
    return true;
}

Du coup on rajoute simplment dans start √† l'image de la success methode

public function start(Request $request, AuthenticationException $authException = null) {
    return new RedirectResponse("/");
}

ET nous voila interdit de form sans se logout. Hmm Hmm. Que s'est'il pass√© ? A suivre üòâ


